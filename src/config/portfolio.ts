export const portfolioConfig = {
  personal: {
    name: "Akshay Babre",
    title: "Frontend Developer",
    subtitle: "Building High-Performance Web Applications",
    email: "akshaybabre8@gmail.com",
    phone: "+91 8431347468",
    location: "Hyderabad, Telangana, India",
    bio: "Frontend Developer specializing in building high-performance, responsive, and accessible web applications using React.js, Node.js, and RESTful APIs. Currently working as a Frontend Developer Intern at Zonevalue, leading the complete frontend development of a B2B real estate portal. Experienced in translating complex business requirements into intuitive UI, integrating APIs for dynamic data, and ensuring cross-browser compatibility. Collaborates closely with senior backend developers using Python/Django to deliver seamless end-to-end solutions. Skilled in state management (Redux/Context API), component-driven architecture, and performance optimization. Strong collaboration skills, working with UX designers, backend engineers, and product managers in Agile environments to deliver scalable solutions.",
    resumeUrl: "https://drive.google.com/uc?export=download&id=135zH95LQKNi172DZ-D6F43odEJx89psG",
    profileImage: "https://i.postimg.cc/3R9HR4Z3/1718556093974.jpg",
    shortBio: "Passionate Frontend Developer skilled in React.js, Node.js, and modern web technologies, building user-centric and scalable applications."
  },

  social: {
    github: "https://github.com/akshaybabre",
    linkedin: "https://linkedin.com/in/akshaybabre",
    twitter: "https://twitter.com/akshaybabre",
    instagram: "https://instagram.com/akshaybabre7"
  },

  education: {
    degree: "Bachelor of Science",
    field: "Computers",
    institution: "C.B Degree College, Bhalki - 585328",
    period: "2021 - 2024",
    cgpa: "7.53 CGPA",
    description: "Passed with 7.53 CGPA. Focused on computer science fundamentals, web technologies, data structures, algorithms, and software engineering principles."
  },

  training: {
    program: "MERN Stack Developer Training",
    institution: "NareshIT, Hyderabad",
    period: "2024 - 2025",
    description: "Completed a 6-month intensive program mastering HTML, CSS, JavaScript, React, Redux, Node.js, and Express.js. Gained hands-on experience by developing full-stack projects using React for frontend development focusing on responsive web applications, RESTful API integration, and clean code practices."
  },

  skills: {
    frontend: [
      { name: "HTML5", level: 90, icon: "üü†", description: "Semantic markup and accessibility" },
      { name: "CSS3", level: 85, icon: "üé®", description: "Modern styling and animations" },
      { name: "JavaScript (ES6+)", level: 90, icon: "üíõ", description: "Modern JavaScript development with ES6+ features" },
      { name: "TypeScript", level: 80, icon: "üìò", description: "Type-safe JavaScript development" },
      { name: "React.js", level: 85, icon: "‚öõÔ∏è", description: "Component-based UI development" },
      { name: "Redux Toolkit", level: 80, icon: "üîÑ", description: "Advanced state management" },
      { name: "React Hooks", level: 80, icon: "üé£", description: "Functional component logic" },
      { name: "Context API", level: 80, icon: "üéØ", description: "React state management" },
      { name: "Tailwind CSS", level: 75, icon: "üí®", description: "Utility-first CSS framework" },
      { name: "Material UI", level: 70, icon: "üé≠", description: "React component library" },
      { name: "Responsive Design", level: 85, icon: "üì±", description: "Mobile-first responsive UIs" },
      { name: "Accessibility (WCAG)", level: 70, icon: "‚ôø", description: "Web accessibility standards" }
    ],
    backend: [
      { name: "Node.js", level: 60, icon: "üü¢", description: "Server-side JavaScript runtime" },
      { name: "Express.js", level: 60, icon: "üöÄ", description: "Web framework for Node.js" },
      { name: "MongoDB", level: 60, icon: "üçÉ", description: "NoSQL database management" },
      { name: "RESTful APIs", level: 75, icon: "üåê", description: "API design and integration" },
      { name: "Axios", level: 70, icon: "üì°", description: "Promise-based HTTP client" }
    ],
    tools: [
      { name: "Git", level: 80, icon: "üìÇ", description: "Version control and collaboration" },
      { name: "GitHub", level: 80, icon: "üê±", description: "Code repository and project management" },
      { name: "Postman", level: 70, icon: "üìÆ", description: "API development and testing" },
      { name: "Netlify", level: 70, icon: "üåê", description: "Static site deployment" },
      { name: "Render", level: 70, icon: "üöÄ", description: "Full-stack app hosting" },
      { name: "CI/CD Pipelines", level: 65, icon: "üîÑ", description: "Continuous integration and deployment" }
    ],
    libraries: [
      { name: "Redux", level: 80, icon: "üîÑ", description: "State management library" },
      { name: "Context API", level: 80, icon: "üéØ", description: "React state management" },
      { name: "Material UI", level: 70, icon: "üé≠", description: "React component library" },
      { name: "Framer Motion", level: 70, icon: "‚ú®", description: "Animation library for React" },
      { name: "Next.js", level: 60, icon: "‚ñ≤", description: "React framework for production" }
    ]
  },

  stats: {
    experience: "1+",
    projects: "2+",
    technologies: "20+",
    successRate: "100%"
  },

  experience: [
    {
      title: "Frontend Developer Intern",
      company: "Zonevalue",
      period: "July 2025 - Present",
      location: "Gurugram, India",
      type: "Internship",
      description: [
        "Leading the complete frontend development of a B2B real estate portal using React.js and TypeScript.",
        "User Management Module: Developed features for user registration, profile updates, and authentication with protected routes.",
        "Property Posting & Approval Flow: Implemented property listing system where users can post properties, receive confirmation emails, and have listings approved by admin before going live.",
        "Lead Management: Built a lead generation feature‚Äîwhen a property is approved and made public, interested users trigger a lead notification to the property owner.",
        "Integrated RESTful APIs with backend (Python/Django) for dynamic data rendering.",
        "Built email notification system for property posting and approval status updates.",
        "Created responsive UI components, optimized performance, and ensured accessibility compliance.",
        "Collaborated with backend developers, participated in Agile sprints, and managed code using Git and CI/CD pipelines."
      ],
      technologies: ["React.js", "TypeScript", "RESTful APIs", "Python/Django", "Git", "CI/CD", "Agile"]
    },
    {
      title: "MERN Stack Training",
      company: "NareshIT",
      period: "2024 - 2025",
      location: "Hyderabad, India",
      type: "Training",
      description: [
        "Completed comprehensive full-stack web development training program",
        "Gained hands-on experience with MongoDB, Express.js, React.js, and Node.js",
        "Built multiple projects demonstrating MERN stack proficiency",
        "Learned industry best practices for web development and deployment",
        "Participated in code reviews and collaborative development exercises"
      ],
      technologies: ["React.js", "Node.js", "MongoDB", "Express.js", "JavaScript", "HTML5", "CSS3"]
    }
  ],

  projects: [
    {
      id: 1,
      title: "Mini-YouTube Application",
      description: "Developed a Scalable 3-Tier Full-Stack App: Built Mini-YouTube with a React frontend, Node.js backend, and MongoDB database, ensuring modularity and scalability. Enhanced Frontend with React and TypeScript: Created a responsive and dynamic UI using React.js, TypeScript, and Tailwind CSS, delivering seamless video browsing, liking/disliking, and watchlist features. Optimized State Management with Redux: Leveraged Redux for robust state synchronization in React, fixing Like/Dislike glitches and improved video interaction response time by 15%, reducing UX complaints. Robust Backend with RESTful APIs: Designed a secure backend using Node.js, Express.js, and Mongoose, integrating Firebase/JWT for authentication and admin routes for content management.",
      image: "https://images.unsplash.com/photo-1649180543887-158357417159?fm=jpg&q=60&w=3000&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8eW91dHViZSUyMGxvZ298ZW58MHx8MHx8fDA%3D",
      technologies: ["React.js", "TypeScript", "Node.js", "MongoDB", "Tailwind CSS", "Framer Motion", "Redux", "Express.js", "JWT", "Firebase"],
      liveUrl: "https://mini-youtube-frontend.onrender.com",
      githubUrl: "https://github.com/akshaybabre/Mini_YouTube_Application",
      featured: true,
      category: "Full Stack"
    },
    {
      id: 2,
      title: "Social Media Application",
      description: "Developed a scalable full-stack social media platform with user authentication, post creation, liking, commenting, and friend management using React.js for a dynamic UI. Integrated RESTful APIs with Node.js, Express.js, and MongoDB Atlas, securing data handling with JWT authentication and 99% uptime on Render deployment. Optimized performance with Redux, reducing interaction response time by 15%, and enhanced security with robust API validation. Designed reusable components and implemented responsive design, improving cross-browser compatibility and user experience. Utilized GitHub for version control and CI/CD pipelines, streamlining development and deployment processes.",
      image: "https://static1.makeuseofimages.com/wordpress/wp-content/uploads/2024/08/some-3d-social-media-icons.jpg",
      technologies: ["React.js", "Node.js", "MongoDB", "Express.js", "MUI", "Redux", "JWT"],
      liveUrl: "https://social-media-frontend-bf86.onrender.com",
      githubUrl: "https://github.com/akshaybabre/Social-Media-Application",
      featured: true,
      category: "Full Stack"
    }
  ],


  blogs: [
    {
      id: 1,
      title: "Building a Scalable React Application: Best Practices",
      excerpt: "Explore key strategies for creating scalable and maintainable React applications with TypeScript and modern tooling.",
      image: "https://strapi.dhiwise.com/uploads/618fa90c201104b94458e1fb_631ecfd981f6071312295177_React_Best_Practices_for_Scalable_Web_Application_Development_OG_image_6dd5c69366.jpg",
      publishedAt: "2024-10-15",
      readTime: "8 min read",
      tags: ["React", "TypeScript", "Web Development", "Frontend"],
      featured: true,
      content: `
        <h2>Introduction</h2>
        <p>Building scalable React applications requires careful planning and adherence to best practices. This article explores strategies to create maintainable, performant, and scalable React applications using TypeScript and modern tooling.</p>
        
        <h2>1. Component Architecture</h2>
        <p>A well-structured component architecture is the foundation of a scalable React application. Organize components into reusable, modular units.</p>
        <ul>
          <li><strong>Atomic Design:</strong> Break down UI into atoms, molecules, organisms, templates, and pages.</li>
          <li><strong>Container vs. Presentational:</strong> Separate logic-heavy containers from dumb presentational components.</li>
          <li><strong>Reusable Hooks:</strong> Encapsulate logic in custom hooks for reusability.</li>
        </ul>
        <p>Example of a reusable hook:</p>
        <pre><code class="language-typescript">
import { useState, useEffect } from 'react';

export const useFetch = (url: string) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
      setLoading(false);
    };
    fetchData();
  }, [url]);

  return { data, loading };
};
        </code></pre>

        <h2>2. Type Safety with TypeScript</h2>
        <p>TypeScript enhances React development by catching errors early and improving code maintainability.</p>
        <ul>
          <li><strong>Typed Props:</strong> Define interfaces for component props.</li>
          <li><strong>Typed State:</strong> Use TypeScript for state management (e.g., Redux Toolkit).</li>
        </ul>
        <p>Example of typed props:</p>
        <pre><code class="language-typescript">
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({ label, onClick, disabled = false }) => {
  return <button onClick={onClick} disabled={disabled}>{label}</button>;
};
        </code></pre>

        <h2>3. Performance Optimization</h2>
        <p>Optimize React applications for speed and efficiency.</p>
        <ul>
          <li><strong>Memoization:</strong> Use <code>React.memo</code> and <code>useMemo</code> to prevent unnecessary re-renders.</li>
          <li><strong>Lazy Loading:</strong> Load components dynamically with <code>React.lazy</code> and <code>Suspense</code>.</li>
          <li><strong>Code Splitting:</strong> Split bundles to reduce initial load time.</li>
        </ul>

        <h2>4. Tooling and Build Setup</h2>
        <p>Use modern tools like Vite or Webpack with TypeScript, ESLint, and Prettier for a robust development environment.</p>
        <p>Recommended tools:</p>
        <ul>
          <li><strong>Vite:</strong> Fast build tool for modern web projects.</li>
          <li><strong>ESLint:</strong> Enforce code quality and consistency.</li>
          <li><strong>Prettier:</strong> Automatic code formatting.</li>
        </ul>

        <h2>Conclusion</h2>
        <p>Building scalable React applications involves thoughtful architecture, type safety, performance optimization, and modern tooling. By following these best practices, you can create robust applications that are easy to maintain and extend.</p>
      `
    },
    {
      id: 2,
      title: "Optimizing Web Performance with Lazy Loading",
      excerpt: "Learn how to boost your web application's performance using lazy loading techniques and modern JavaScript.",
      image: "https://res.cloudinary.com/cloudinary-marketing/images/f_auto,q_auto/v1649719961/Web_Assets/blog/Lazy-Loading-JavaScript_22090f21a4/Lazy-Loading-JavaScript_22090f21a4.png?_i=AA",
      publishedAt: "2024-09-20",
      readTime: "6 min read",
      tags: ["JavaScript", "Performance", "Frontend"],
      featured: false,
      content: `
        <h2>Introduction</h2>
        <p>Lazy loading is a technique to defer loading of non-critical resources until they are needed, improving web performance. This article explores lazy loading for images, components, and routes.</p>

        <h2>1. Lazy Loading Images</h2>
        <p>Loading images only when they enter the viewport reduces initial page load time.</p>
        <ul>
          <li><strong>HTML <code>loading="lazy"</code>:</strong> Native browser support for lazy loading images.</li>
          <li><strong>Intersection Observer:</strong> Programmatically load images when they are visible.</li>
        </ul>
        <p>Example using Intersection Observer:</p>
        <pre><code class="language-javascript">
const images = document.querySelectorAll('img[data-src]');

const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

images.forEach((img) => observer.observe(img));
        </code></pre>

        <h2>2. Lazy Loading React Components</h2>
        <p>In React, use <code>React.lazy</code> and <code>Suspense</code> to load components dynamically.</p>
        <p>Example:</p>
        <pre><code class="language-typescript">
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <LazyComponent />
  </Suspense>
);
        </code></pre>

        <h2>3. Route-Based Lazy Loading</h2>
        <p>Split your application into smaller chunks by lazy loading routes.</p>
        <p>Example with React Router:</p>
        <pre><code class="language-typescript">
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import { lazy, Suspense } from 'react';

const Home = lazy(() => import('./pages/Home'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
      </Routes>
    </Suspense>
  </Router>
);
        </code></pre>

        <h2>4. Measuring Performance</h2>
        <p>Use tools like Lighthouse and Web Vitals to measure the impact of lazy loading.</p>
        <ul>
          <li><strong>Largest Contentful Paint (LCP):</strong> Measures main content loading time.</li>
          <li><strong>First Contentful Paint (FCP):</strong> Measures initial render time.</li>
        </ul>

        <h2>Conclusion</h2>
        <p>Lazy loading significantly improves web performance by reducing initial load times and optimizing resource usage. Implement it for images, components, and routes to enhance user experience.</p>
      `
    },
    {
      id: 3,
      title: "Mastering State Management in React",
      excerpt: "A deep dive into Redux, Context API, and other state management solutions for complex React applications.",
      image: "https://miro.medium.com/v2/resize:fit:1400/1*HeJahz1pxt_x0E14yF7QfQ.png",
      publishedAt: "2024-08-10",
      readTime: "10 min read",
      tags: ["React", "Redux", "State Management", "Frontend"],
      featured: false,
      content: `
        <h2>Introduction</h2>
        <p>State management is critical for building complex React applications. This article compares Redux, Context API, and other solutions to help you choose the right approach.</p>

        <h2>1. Context API</h2>
        <p>The Context API is a built-in solution for managing global state in React.</p>
        <ul>
          <li><strong>Use Case:</strong> Simple global state (e.g., theme, user authentication).</li>
          <li><strong>Pros:</strong> No external dependencies, easy to set up.</li>
          <li><strong>Cons:</strong> Can cause unnecessary re-renders in large apps.</li>
        </ul>
        <p>Example:</p>
        <pre><code class="language-typescript">
import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const useTheme = () => useContext(ThemeContext);
        </code></pre>

        <h2>2. Redux Toolkit</h2>
        <p>Redux Toolkit simplifies Redux setup with modern best practices.</p>
        <ul>
          <li><strong>Use Case:</strong> Complex state logic with multiple components.</li>
          <li><strong>Pros:</strong> Predictable state updates, powerful dev tools.</li>
          <li><strong>Cons:</strong> Steeper learning curve.</li>
        </ul>
        <p>Example slice:</p>
        <pre><code class="language-typescript">
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
        </code></pre>

        <h2>3. Other Solutions</h2>
        <p>Explore alternatives like Zustand and MobX for lightweight state management.</p>
        <ul>
          <li><strong>Zustand:</strong> Simple API, minimal boilerplate.</li>
          <li><strong>MobX:</strong> Reactive state management with observables.</li>
        </ul>

        <h2>4. Choosing the Right Tool</h2>
        <p>Consider app size, complexity, and team familiarity when selecting a state management solution.</p>
        <ul>
          <li>Use Context API for small to medium apps.</li>
          <li>Use Redux Toolkit for large, complex apps.</li>
          <li>Explore Zustand or MobX for lightweight alternatives.</li>
        </ul>

        <h2>Conclusion</h2>
        <p>Effective state management improves React application scalability and maintainability. Choose the right tool based on your project's needs and complexity.</p>
      `
    },
    {
      id: 4,
      title: "Getting Started with React Server Components",
      excerpt: "Understand how React Server Components work, their benefits, and how to integrate them into your modern React applications.",
      image: "https://react.dev/images/og-home.png",
      publishedAt: "2024-11-05",
      readTime: "7 min read",
      tags: ["React", "Server Components", "Next.js", "Frontend"],
      featured: false,
      content: `
        <h2>Introduction</h2>
        <p>React Server Components (RSC) are a new paradigm for building React applications, allowing components to run on the server to reduce client-side JavaScript. This article covers their setup, benefits, and integration with Next.js.</p>

        <h2>1. What Are React Server Components?</h2>
        <p>RSC are components that render on the server and send minimal JavaScript to the client.</p>
        <ul>
          <li><strong>Zero Client-Side JS:</strong> Reduces bundle size.</li>
          <li><strong>Data Fetching:</strong> Perform server-side data fetching.</li>
          <li><strong>SEO Benefits:</strong> Improves search engine indexing.</li>
        </ul>

        <h2>2. Setting Up React Server Components</h2>
        <p>Use Next.js App Router to implement RSC.</p>
        <p>Example server component:</p>
        <pre><code class="language-typescript">
import { getData } from './api';

export default async function ServerComponent() {
  const data = await getData();
  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.description}</p>
    </div>
  );
}
        </code></pre>

        <h2>3. Combining Server and Client Components</h2>
        <p>Use client components for interactive elements and server components for static content.</p>
        <p>Example client component:</p>
        <pre><code class="language-typescript">
'use client';

import { useState } from 'react';

export default function ClientComponent() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
        </code></pre>

        <h2>4. Benefits of React Server Components</h2>
        <ul>
          <li><strong>Performance:</strong> Reduced client-side JavaScript improves load times.</li>
          <li><strong>Data Access:</strong> Direct access to server-side resources (e.g., databases).</li>
          <li><strong>Security:</strong> Sensitive logic stays on the server.</li>
        </ul>

        <h2>5. Challenges and Limitations</h2>
        <p>RSC cannot use hooks or event handlers, as they run only on the server.</p>

        <h2>Conclusion</h2>
        <p>React Server Components offer a powerful way to optimize React applications. By leveraging Next.js, developers can build performant, SEO-friendly apps with minimal client-side JavaScript.</p>
      `
    }
  ]
};